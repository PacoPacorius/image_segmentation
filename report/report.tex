\documentclass{article} 
\usepackage{polyglossia} 
\usepackage{amsmath}
\usepackage{fontspec} 
\usepackage{lipsum} 
\usepackage[margin=1in]{geometry}
\usepackage{graphicx} 
\usepackage[figurename=Εικόνα]{caption} 
\usepackage{subcaption}
\usepackage{hyperref} 
\usepackage{listing}
\hypersetup{% 
    colorlinks=true, linkcolor=blue, filecolor=magenta,      
    urlcolor=cyan, 
    pdfinfo = {%
        Title = Αναφορά 3ης Εργασίας ΨΕΕ
        Author = {Χρήστος Μάριος Περδίκης},
        Producer = XeLaTeX,
    } 
}

\renewcommand{\figureautorefname}{Εικόνα}
\setmainfont{Nimbus Roman}

\title{Ψηφιακή Επεξεργασία Εικόνας \\ Image Segmentation}
\date{Εαρινό Εξάμηνο 2024-2025}
\author{Χρήστος-Μάριος Περδίκης 10075 cperdikis@ece.auth.gr}

\begin{document}
\maketitle
Σε αυτήν την εργασία υλοποιείται σε python η αναπαράσταση εικόνων σε γράφους και image
segmentation με τις μεθόδους spectral clustering και normalized cuts.


\section{Συνάρτηση img\_to\_graph()}
Η συνάρτηση img\_to\_graph() βρίσκεται στο αρχείο img\_to\_graph.py. Η είσοδός της
είναι το array της εικόνας εισόδου του προγράμματος. Το array της εικόνας 
ανασχηματίζεται έτσι ώστε κάθε γραμμή να αντιστοιχεί σε ένα pixel με C κανάλια.
Αυτό θα απλουστεύσει τις πράξεις. Για τον υπολογισμό των ευκλείδιων αποστάσεων 
μεταξύ των pixel της εικόνας χρησιμοποιείται η συνάρτηση scipy.spatial.distance.cdist()
για λόγους αποδοτικότητας. Έπειτα δημιουργείται ο affinity matrix:

\begin{equation}
    \text{affinity\_mat} = \frac{1}{e^{distances}}
\end{equation}
όπου $distances$ το array που περιέχει τις ευκλείδιες αποστάσεις κάθε ζεύγους
pixel στην εικόνα. Τέλος στον πίνακα affinity matrix τοποθετούνται άσσοι στην
διαγώνιό του, για να είναι σίγουρο ότι το ζεύγος ενός pixel με τον εαυτό του
είναι ακριβώς 1 και επιστρέφεται ο πίνακας affinity matrix.

\section{Συνάρτηση spectral\_clustering()}
Η συνάρτηση spectral\_clustering() βρίσκεται στο αρχείο spectral\_clustering().
Η είσοδος της συνάρτησης είναι ένα affinity matrix που περιγράφει τον γράφο μιας
εικόνας και ο ακέραιος k που θα καθορίσει σε πόσα clusters θα χωρίσουμε την εικόνα.
Κατασκευάζεται το degree matrix από το affinity matrix:

\begin{equation}
    D(i, i) \sum_j W(i, j)
\end{equation}
Έπειτα υπολογίζεται ο Λαπλασιανός πίνακας:

\begin{equation}
    L = D - W
\end{equation}
Βρίσκονται οι ιδιοτιμές και τα ιδιοδιανύσματα του Λαπλασιανού πίνακα. 
\begin{equation}
    Lx = \lambda x
\end{equation}
Η συνάρτηση scipy.sparse.linalg.eigs() καλείται με ορίσματα k=$k$ και 
which='SM', έτσι ώστε η συνάρτηση να επιστρέψει τις $k$ μικρότερες σε μέτρο
ιδιοτιμές και τα αντίστοιχα ιδιοδιανύσματα. Οι ιδιοτιμές και τα ιδιοδιανύσματα
ταξινομούνται με βάση το μέτρο των ιδιοτιμών. Η συνάρτηση sklearn.cluster.KMeans()
δεν υποστηρίζει φανταστικούς αριθμούς, οπότε ο πίνακας $U$ δημιουργείται με
το πραγματικό μόνο μέρος των ιδιοδιανυσμάτων και μετά πραγματοποιείται k-means 
clustering όπως απαιτεί η εκφώνηση της εργασίας. Το array με τις ετικέτες που 
δείχνουν σε ποιό cluster ανήκουν οι κορυφές του γράφου (δηλαδή κάθε pixel της
εικόνας) είναι η έξοδος της συνάρτησης spectral\_clustering().

\section{Εφαρμογές}
\subsection{demo1} 
Στο demo 1 γίνεται η επίδειξη της συνάρτησης spectral\_clustering(). Ο 
προ-κατασκευασμένος affinity πίνακας d1a φορτώνεται από το αρχείο dip\_hw\_3.mat. 
Έπειτα καλείται η συνάρτηση spectral\_clustering() με είσοδο d1a για τιμές $k = 2,3,4$.
Τέλος γίνεται μονοδιάστατη οπτικοποίηση των αποτελεσμάτων στην οποία φαίνεται 
σε ποιό cluster ανήκει κάθε vertex. 
Βλέπουμε στην~\autoref{figure1} ότι οι 11 κόμβοι του γράφου που μας δόθηκε
χωρίζονται σε 2, 3 και 4 clusters, ανάλογα με την τιμή του $k$.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{Figure_1.png}
    \caption{Αποτελέσματα spectral clustering σε έτοιμο affinity matrix}\label{figure1}
\end{figure}


\subsection{demo2}
Στο demo 2 γίνεται η επίδειξη και της συνάρτησης img\_to\_graph() μαζί με τη 
spectral\_clustering(). Οι εικόνες d2a και d2b φορτώνονται από το αρχείο 
dip\_hw\_3.mat. Γίνονται έλεγχοι αν οι εικόνες εισόδου πληρούν τις προϋποθέσεις 
της img\_to\_graph(), δηλαδή να είναι έγχρωμες και οι τιμές τους να κυμαίνονται 
στο διάστημα $[0,1]$. Για κάθε μία από τις δύο εικόνες υπολογίζεται πρώτα το
affinity matrix με τη χρήση της img\_to\_graph() και αυτό γίνεται η είσοδος
της spectral\_clustering(). Για κάθε μία από τις δύο εικόνες η συνάρτηση 
spectral\_clustering() τρέχει για τιμές $k = 2,3,4$, συνολικά 6 φορές. Οι
ετικέτες του clustering τοποθετούνται στις θέσεις των pixels τα οποία περιγράφουν
και εμφανίζονται στην οθόνη δίπλα στις αρχικές εικόνες τα αποτελέσματα για όλες 
τις τιμές του $k$. Διαφορετικά clusters έχουν διαφορετικά χρώματα. Βλέπουμε 
στην~\autoref{figure2} ότι στην πρώτη εικόνα που μας δόθηκε χωρίζονται σωστά 
οι στήλες χρώματος για $k=2,3$. Για $k=4$ όμως βλέπουμε δύο μικρά κουτάκια 
μέσα στην κόκκινη στήλη, υπάρχει ένα τέταρτο cluster σε μια περιοχή που
στην αρχική εικόνα είναι ομογενής και δεν έχει λόγο να μην ανήκει στο 
ίδιο cluster. Στη κάτω εικόνα βλέπουμε ότι για $k=2$ στο ένα cluster ανήκουν
τα πολύ άσπρα pixels (οι γωνίες της εικόνας και σημεία από τα γάντια του Mario)
και όλα τα υπόλοιπα pixels στο άλλο cluster. Για $k=3$, στο νέο cluster 
ομαδοποιούνται pixel με κόκκινο ή καφετί χρώμα (τα ρούχα του Mario κάτω από
τη σαλοπέτα, τα παπούτσια του, το καπέλο του, οι φαβορίτες του). Για $k=4$ 
όμως πάλι δεν λαμβάνουμε καμιά νέα πληροφορία για την εικόνα, στο νέο 
cluster ανήκουν pixel από το καπέλο του Mario που στην αρχική εικόνα
δεν ξεχωρίζουν με κάποιον τρόπο.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{Figure_2.png}
    \caption{Αποτελέσματα spectral clustering σε εικόνες}\label{figure2}
\end{figure}

\section{Συνάρτηση n\_cuts()}
Η συνάρτηση n\_cuts() βρίσκεται στο αρχείο n\_cuts.py. Η είσοδος της συνάρτησης 
είναι ένα affinity matrix και ο αριθμός των clusters που θα δημιουργηθούν $k$.
Όμοια με τη συνάρτηση spectral\_clustering() κατασκευάζεται το degree matrix 
και υπολογίζεται ο Λαπλασιανός πίνακας $L$. Εδώ είναι η διαφοροποίηση με τη
spectral\_clustering(), λύνεται η γενικευμένη εξίσωση ιδιοτιμών:

\begin{gather}
    Lx = \lambda Dx \Rightarrow \\
    D^{-1} Lx = \lambda x
\end{gather}
και βρίσκονται ιδιοτιμές και τα αντίστοιχα ιδιοδιανύσματα. Η συνάρτηση 
scipy.sparse.linalg.eigs() καλείται με ορίσμα\-τα k=$k$ και 
which='SM', έτσι ώστε η συνάρτηση να επιστρέψει τις $k$ μικρότερες σε μέτρο
ιδιοτιμές. Τέλος δημιουργεί\-ται ο πίνακας $U$
που έχει στήλες τα ιδιοδιανύσματα του Λαπλασιανού πίνακα $L$ και ομαδοποιούνται
οι γραμμές του $U$ με τη μέθοδο k-means. Έξοδος της συνάρτησης είναι το array 
cluster\_idx που περιέχει τις ετικέτες που δηλώνουν σε ποιό cluster ανήκει κάθε
κόμβος του γράφου.

\section{Συνάρτηση n\_cuts\_recursive()}
Η συνάρτηση βρίσκεται στο αρχείο n\_cuts.py. Οι είσοδοί της είναι ένα affinity matrix 
και τα threshold T1 και T2. Στο στάδιο της αρχικοποίησης, θεωρούνται ότι όλοι
οι κόμβοι του γράφου ανήκουν σε ένα αρχικό label. Σε κάθε επανάληψη της αναδρομής,
ελέγχεται αν ο αριθμός των pixels που ανήκουν στην τωρινή ετικέτα είναι μικρότερος
από το threshold T1. Στην πρώτη επανάληψη αυτή είναι η αρχική ετικέτα 0 στην οποία 
ανήκουν όλα τα pixels της εικόνας. Αν είναι μικρότερος, η συνάρτηση επιστρέφει 
και η αναδρομή τελειώνει. Βρίσκονται ο υπογράφος του γράφου που περιγράφει το
affinity matrix για τον οποίο όλοι οι κόμβοι ανήκουν στο τωρινό cluster. Ο
υπογράφος χωρίζεται στα δύο καλώντας τη συνάρτηση n\_cuts() για $k=2$. 
Υπολογίζεται η τιμή n\_cut με κλήση της συνάρτησης calculate\_n\_cut\_value()
με ορίσματα τις δύο νέες ετικέτες και το affinity matrix του υπογράφου.
Αν η n\_cut είναι μεγαλύτερη από το threshold T2 η συνάρτηση επιστρέφει και τελειώνει η
αναδρομή χωρίς να ληφθεί υπόψιν ο τελευταίος χωρισμός του υπογράφου. Αλλιώς,
η αναδρομή συνεχίζει για τα δύο subclusters που δημιουργήθηκαν. Πριν η 
κάθε αναδρομή τελειώσει, η τωρινή ετικέτα αναθέτεται σε όλα τα pixel
του τωρινού cluster, εφόσον αυτό δεν θα χωριστεί περαιτέρω. Η έξοδος της
συνάρτησης είναι το τελικό cluster\_idx.

\section{Συνάρτηση calculate\_ncut\_value()}
Η συνάρτηση αυτή βρίσκεται στο αρχείο n\_cuts.py. Οι είσοδοί της είναι ένα 
affinity matrix που περιγράφει ένα γράφο / εικόνα και το cluster\_idx array 
που δηλώνει ποιά pixel της εικόνας ανήκουν σε ποιό cluster. Αναγκαστικά το
cluster\_idx μπορεί να δείχνει μόνο δύο clusters, και για να σιγουρευτεί η
αλήθεια αυτής της προϋπόθεσης γίνεται έλεγχος. Υπολογίζονται οι 
μετρικές assoc(A,A), assoc(A,V), assoc(B,B) και assoc(B,V), όπου A,B τα δύο
clusters και V ολοόκληρος ο γράφος (ο οποίος περιγράφεται από το affinity
matrix, μπορεί να είναι μικρότερος από την αρχική εικόνα). Η μετρική assoc()
υπολογίζεται ως εξής:

\begin{equation}
    assoc(A,V) = \sum_{i, j} W(i, j)
\end{equation}
όπου $i$ τα indices των κόμβων του affinity πίνακα που ανήκουν στο cluster A
και $j$ τα indices όλων των κόμβων του affinity matrix. Έπειτα υπολογίζεται η 
τιμή n\_cut:

\begin{equation}
    n\_cut = 2 - \left(\frac{assoc(A,A)}{assoc(A,V)} + \frac{assoc(B,B)}{assoc(B,V)}\right)
\end{equation}
η οποία είναι και η έξοδος της συνάρτησης.

\section{Εφαρμογές}
\subsection{demo3a} 
Στο αρχείο demo3a.py γίνεται η επίδειξη της συνάρτησης n\_cuts(). Οι
δοσμένες εικόνες d2a και d2b φορτώνονται από το αρχείο 
dip\_hw\_3.mat. Γίνονται έλεγχοι αν οι εικόνες εισόδου πληρούν τις προϋποθέσεις 
της img\_to\_graph(), δηλαδή να είναι έγχρωμες και οι τιμές τους να κυμαίνονται 
στο διάστημα $[0,1]$. Για κάθε μία από τις δύο εικόνες υπολογίζεται πρώτα το
affinity matrix με τη χρήση της img\_to\_graph(). Για κάθε affinity matrix και 
για τις τιμές $k=2,3,4$ καλείται η συνάρτηση n\_cuts() (συνολικά 6 φορές).
Οι ετικέτες του clustering τοποθετούνται στις θέσεις των pixels τα οποία περιγράφουν
και εμφανίζονται στην οθόνη δίπλα στις αρχικές εικόνες τα αποτελέσματα για όλες 
τις τιμές του $k$ (\autoref{figure3}). Βλέπουμε στην πάνω εικόνα με τις στήλες χρώματος
τα ίδια αποτελέσματα με τη μέθοδο spectral clustering για τιμές $k=2,3$, τα όρια 
των clusters είναι τα όρια των στηλών χρώματος. Για $k=4$ σε σχέση με τη μέθοδο 
spectral\_clustering() έχουμε περισσότερα
pixels που ανήκουν στο τέταρτο cluster, το οποίο δν προσφέρει καμία πληροφορία.
Στην κάτω εικόνα βλέπουμε ήδη για $k=2$ ότι η σιλουέτα του Mario διαγράφεται 
καλύτερα σε σχέση με τη μέθοδο spectral clustering. Στο ένα cluster ανήκουν 
όλα τα pixel που δεν είναι γενικά μπλε και στο
άλλο ανήκουν το background, το παντελόνι και τα μπλε μάτια του Mario. Για $k=3$,
τα clusters χωρίζονται σε κόκκινο-καφέ, άσπρο-χρώμα δέρματος και μπλε. Ακόμα και
αν δεν είχαμε την αρχική εικόνα, θα μπορούσαμε από αυτήν την εικόνα να αναγνωρίσουμε
ότι απεικονίζεται ο Mario. Για $k=4$ η μέθοδος normalized cuts κατάφερε να διαχωρίσει
το σκούρο μπλε του παντελονιού του Mario και το φωτεινό μπλε background σε 
διαφορετικά clusters. Από την άλλη έχουμε υπερβολική λεπτομέρεια στα σημεία όπου 
τα κόκκινα borders γίνονται μπλε background η οποία δεν είναι ιδιαίτερα βοηθητική.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{Figure_3.png}
    \caption{Αποτελέσματα μεθόδου normalized cuts (non-recursive) σε εικόνες}\label{figure3}
\end{figure}

\subsection{demo3b}
Στο αρχείο demo3b.py γίνεται η επίδειξη της μεθόδου recursive normalized cuts. Όμοια
με το demo3a.py φορτώνονται οι δοσμένες εικόνες d2a, d2b και υπολογίζονται τα affinity 
matrices τους με την img\_to\_graph(). Έπειτα εκτελείται το πρώτο βήμα της recursive
n-cuts μεθόδου. Καλείται η συνάρτηση n\_cuts() με ορίσμα\-τα τους πίνακες affinity 
των εικόνων και $k=2$. Υπολογίζεται η τιμή n\_cut καλώντας την συνάρτηση 
calculate\_n\_cut\_value(). Τα ορίσμα\-τά της είναι ο πίνακας affinity και το
array cluster\_idx έξοδος της n\_cuts(). Έπειτα προβάλλεται στην οθόνη η 
αρχική εικόνα, η εικόνα με τα δύο διαφορετικά clusters και η τιμή n\_cut.
Βλέπουμε στην~\autoref{figure4} ότι για $k=2$, τα αποτελέσματα είναι τα 
ίδια με την῀\autoref{figure3}. Η τιμή n\_cut για την πάνω περίπτωση είναι περίπου 0.51 και για 
την κάτω περίπου 0.78. 

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{Figure_4.png}
    \caption{Αποτελέσματα recursive n-cuts μεθόδου για μία επανάληψη}\label{figure4}
\end{figure}

\subsection{demo3c}
Στο αρχείο demo3c.py γίνεται η επίδειξη της ολοκληρωμένης μεθόδου recursive 
normalized cuts. Όμοια με το demo3a.py φορτώνονται οι δοσμένες εικόνες d2a, d2b και υπολογίζονται τα affinity 
matrices τους με την img\_to\_graph(). Έπειτα καλείται η  n\_cuts\_recursive() 
με ορίσματα τον affinity πίνακα του γράφου της εικόνας και thresholds $T1=5$, $T2=0.2$. Βλέπουμε
από την~\autoref{figure5} ότι η αναδρομική μέθοδος δεν έτρεξε ούτε μια φορά και όλα τα pixels
και στις δύο εικόνες είναι σε ένα cluster, το αρχικό. Αυτό είναι το αναμενόμενο
αποτέλεσμα, αφού υπολογίσαμε στο demo3b.py τις n\_cut τιμές των αρχικών εικόνων 
0.51 και 0.78, πολύ μεγαλύτερες από το threshold $T2=0.2$.

Επειδή δεν έχουμε δει ακόμα την n\_cuts\_recursive() με αναδρομία, ξαναέτρεξα το
demo3c.py για $T2=0.8$. Βλέπουμε τα αποτελέσματα στην~\autoref{figure6}. Στην 
πάνω περίπτωση τα αποτελέσματα είναι ακριβώς ίδια για την περίπτωση της 
μη αναδρομικής n-cuts μεθόδου για $k=3$. Για την κάτω περίπτωση είναι 
γενικά παρόμοιο με τη μη-αναδρομική μέθοδο για $k=3$, 
ένα cluster για άσπρο χρώμα και χρώμα δέρματος, ένα cluster 
για καφέ και κόκκινο και ένα cluster για το μπλε. Μπορούμε να
δούμε μικρές διαφορές στα κόκκινα borders, στο ένα γάντι του Mario
και γύρω απο τα χρυσά κουμπιά στη σαλοπέτα του. Προφανώς η σωστή 
λειτουργία της n\_cuts\_recursive() εξαρτάται από την επιλογή 
του threshold $T2$. 

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{Figure_5.png}
    \caption{Αποτελέσματα αναδρομικής n-cuts μεθόδου για $T2=0.2$}\label{figure5}
\end{figure}


\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{Figure_6.png}
    \caption{Αποτελέσματα αναδρομικής n-cuts μεθόδου για $T2=0.8$}\label{figure6}
\end{figure}

\end{document}
